#   Шаг 1.  Удаление пропущенных значений
    data.02 <- na.omit(x.data)


#   Шаг 2.  Стандартизация переменных.
{
#   В данной задаче переменные измерены в одной и той же шкале.
#   В порядке исключения стандартизировать не надо.
#   В будущем, чтобы стандартизировать столбцы

#   Вариант 1 - к среднему 0 и ст отклонению 1
#   beverage.02 <- scale(beverage.01[,2:9], center = TRUE, scale = TRUE)

#   Вариант 2 - к минимуму 0 и максимуму 1
#   maxs <- apply(a, 2, max)
#   mins <- apply(a, 2, min)
#   beverage.02 <- scale(a, center = mins, scale = maxs - mins)

#   Вариант 3 - использовать rescaler функцию из пакета reshape
#   Вариант 4 - использовать data.Normalization функцию из пакета clusterSim
}

#  Шаг 3.  процедура кластерного анализа
#  результаты записываются в лист clust.data.02

#  Создаем матрицу попарных расстояний
#  Проводим кластерный анализ, 
#  результаты записываем в список clust.data.02

clust.data.02 <- hclust(dist(data.02), "ward.D")

#  Смотрим краткую сводку результатов анализа
clust.data.02

#!!!
{
#  Если нам нужно расстояние, которое не реализовано 
#  в процедуре dist, создаем матрицу расстояний Х, 
#  приписываем ей класс dist командой as.dist(X)
}

#  Шаг 5.  Построение дендрограммы
#  Возможны две версии команды

#plot(clust.data.02)
plot(clust.data.02, hang = -1)

# Сделаем красиво
# на дендрограмме красными прямоугольниками выделим 3 кластера
rect.hclust(clust.data.02, k=3, border="red") 


#  Шаг 6.  Определение числа кластеров

#  Разделим пользователей на 3 кластера
#  Вектор groups содержит номер кластера, в который попал классифицируемый объект 

groups <- cutree(clust.data.02, k=3) 
groups

#  Отступление
#  Обзор результатов процедуры кластерного анализа
#===================================================

# какие результаты хранятся в списке clust.beverage?
names(clust.data.02)
# история объединения кластеров
clust.data.02$merge
#  расстояния между кластерами в момент объединения
clust.data.02$height
#  порядок следования объектов на дендрограмме
clust.data.02$order
# метки классифицируемых объектов
clust.data.02$labels
#  метод вычисления расстояний между кластерами
clust.data.02$method
#  текст выполняемой команды
clust.data.02$call
#  метод вычисления расстояний между объектами
clust.data.02$dist.method

#  --------------------------------------------

# Выводы:
# Здесь 3 кластера
> groups
[1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 1 1
[39] 1 2 2 2 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3
[77] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 2
#Чётко видно, что с течением времени дважды 
#кардинально менялось влияние на фитировку